import{_ as a,o as t,c as e,Q as r}from"./chunks/framework.874cb1ca.js";const o="/blog/tls.jpg",m=JSON.parse('{"title":"HTTPS 握手","description":"","frontmatter":{"layout":"doc"},"headers":[],"relativePath":"network/HTTPS握手.md","filePath":"network/HTTPS握手.md"}'),i={name:"network/HTTPS握手.md"},n=r('<h1 id="https-握手" tabindex="-1">HTTPS 握手 <a class="header-anchor" href="#https-握手" aria-label="Permalink to &quot;HTTPS 握手&quot;">​</a></h1><p><img src="'+o+'" alt="An image"></p><h2 id="中间人攻击" tabindex="-1">中间人攻击 <a class="header-anchor" href="#中间人攻击" aria-label="Permalink to &quot;中间人攻击&quot;">​</a></h2><p>在非对称加密通信过程中，服务器需要将公钥发送给客户端，在这一过程中，公钥很可能会被第三方拦截并替换，然后这个第三方就可以冒充服务器与客户端进行通信，这就是传说中的“中间人攻击”(man in the middle attack)。</p><h2 id="数字证书" tabindex="-1">数字证书 <a class="header-anchor" href="#数字证书" aria-label="Permalink to &quot;数字证书&quot;">​</a></h2><p>解决此问题的方法是通过受信任的第三方交换公钥，具体做法就是服务器不直接向客户端发送公钥，而是要求受信任的第三方，也就是证书认证机构 (Certificate Authority, 简称 CA)将公钥合并到数字证书中，然后服务器会把公钥连同证书一起发送给客户端，私钥则由服务器自己保存以确保安全。</p><h2 id="过程总结" tabindex="-1">过程总结 <a class="header-anchor" href="#过程总结" aria-label="Permalink to &quot;过程总结&quot;">​</a></h2><ul><li><p>非对称加密确认密钥</p></li><li><p>对称加密进行通信</p></li></ul><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><p><a href="https://juejin.cn/post/6844904132071948295" target="_blank" rel="noreferrer">https://juejin.cn/post/6844904132071948295</a></p>',10),l=[n];function s(h,c,_,d,p,u){return t(),e("div",null,l)}const f=a(i,[["render",s]]);export{m as __pageData,f as default};
