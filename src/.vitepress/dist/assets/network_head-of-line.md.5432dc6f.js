import{_ as t,o as e,c as a,Q as o}from"./chunks/framework.874cb1ca.js";const r="/blog/pipe.jpg",m=JSON.parse('{"title":"队头阻塞","description":"","frontmatter":{"layout":"doc"},"headers":[],"relativePath":"network/head-of-line.md","filePath":"network/head-of-line.md"}'),p={name:"network/head-of-line.md"},h=o('<h1 id="队头阻塞" tabindex="-1">队头阻塞 <a class="header-anchor" href="#队头阻塞" aria-label="Permalink to &quot;队头阻塞&quot;">​</a></h1><h2 id="http1-0" tabindex="-1">http1.0： <a class="header-anchor" href="#http1-0" aria-label="Permalink to &quot;http1.0：&quot;">​</a></h2><p>一个 http 链接就要建立一次 tcp 请求，消耗大。通过开启 Keep-Alive 可以实现持久链接。</p><h2 id="http1-1" tabindex="-1">http1.1： <a class="header-anchor" href="#http1-1" aria-label="Permalink to &quot;http1.1：&quot;">​</a></h2><p>默认开启了 Keep-Alive 进行持久链接。并且可以通过开启管道化一次性发起多个请求。</p><p><strong>管道化解决了用户端的队头阻塞问题，但是没有解决服务端的队头阻塞问题。因此现代浏览器默认都关闭了管道化，大多采用并行连接与持久连接共用的方式提高访问速度，对每个域名建立并行地少量持久连接。</strong></p><p><img src="'+r+'" alt="An image"></p><h2 id="http2-0" tabindex="-1">http2.0： <a class="header-anchor" href="#http2-0" aria-label="Permalink to &quot;http2.0：&quot;">​</a></h2><p>引入了帧、消息和数据流等概念，每个请求/响应被称为消息，每个消息都被拆分成若干个帧进行传输，每个帧都分配一个序号。每个帧在传输是属于一个数据流，而一个连接上可以存在多个流，各个帧在流和连接上独立传输，<strong>到达之后再组装</strong>成消息，这样就避免了请求/响应阻塞。</p><p>但是 http2.0 底层使用了 tcp，仍然无法避免 tcp 链接的队头阻塞问题。</p><h2 id="tcp" tabindex="-1">TCP <a class="header-anchor" href="#tcp" aria-label="Permalink to &quot;TCP&quot;">​</a></h2><p>TCP 中的队头阻塞的产生是由 TCP 自身的实现机制决定的，无法避免。想要在应用程序当中避免 TCP 队头阻塞带来的影响，只有舍弃 TCP 协议。HTTP 2.0 over QUIC 也可以称为 HTTP 3.0，它使用 UDP 实现了一个可靠的多路复用传输层。</p>',12),n=[h];function i(s,c,l,d,_,P){return e(),a("div",null,n)}const u=t(p,[["render",i]]);export{m as __pageData,u as default};
